GETFSSTAT(2)		    BSD System Calls Manual		  GETFSSTAT(2)

NNAAMMEE
     ggeettffssssttaatt -- get list of all mounted file systems

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ppaarraamm..hh>>
     ##iinncclluuddee <<ssyyss//uuccrreedd..hh>>
     ##iinncclluuddee <<ssyyss//mmoouunntt..hh>>

     _i_n_t
     ggeettffssssttaatt(_s_t_r_u_c_t _s_t_a_t_f_s _*_b_u_f, _i_n_t _b_u_f_s_i_z_e, _i_n_t _f_l_a_g_s);

TTRRAANNSSIITTIIIIOONNAALL SSYYNNOOPPSSIISS ((NNOOWW DDEEPPRREECCAATTEEDD))
     _i_n_t
     ggeettffssssttaatt6644(_s_t_r_u_c_t _s_t_a_t_f_s_6_4 _*_b_u_f, _i_n_t _b_u_f_s_i_z_e, _i_n_t _f_l_a_g_s);

DDEESSCCRRIIPPTTIIOONN
     The ggeettffssssttaatt() function returns information about all mounted file sys-
     tems.  The _b_u_f argument is a pointer to an array of statfs structures.

     As of Mac OS X 10.6, the default size of the _i_n_o___t type is 64 bits (the
     macro _DARWIN_FEATURE_64_BIT_INODE will be defined).  While there is no
     _i_n_o___t type used in the statfs structure, the changes to ggeettffssssttaatt() are
     grouped together with the 64-bit inode changes.  The string fields in the
     statfs structure are larger and the variant symbol _getfsstat$INODE64
     will be automatically used.  The statfs structure is defined as:

     typedef struct { int32_t val[2]; } fsid_t;

     #define MFSTYPENAMELEN  16 /* length of fs type name including null */
     #define MAXPATHLEN      1024
     #define MNAMELEN	     MAXPATHLEN

     struct statfs { /* when _DARWIN_FEATURE_64_BIT_INODE is defined */
	 uint32_t    f_bsize;	     /* fundamental file system block size */
	 int32_t     f_iosize;	     /* optimal transfer block size */
	 uint64_t    f_blocks;	     /* total data blocks in file system */
	 uint64_t    f_bfree;	     /* free blocks in fs */
	 uint64_t    f_bavail;	     /* free blocks avail to non-superuser */
	 uint64_t    f_files;	     /* total file nodes in file system */
	 uint64_t    f_ffree;	     /* free file nodes in fs */
	 fsid_t      f_fsid;	     /* file system id */
	 uid_t	     f_owner;	     /* user that mounted the filesystem */
	 uint32_t    f_type;	     /* type of filesystem */
	 uint32_t    f_flags;	     /* copy of mount exported flags */
	 uint32_t    f_fssubtype;    /* fs sub-type (flavor) */
	 char	     f_fstypename[MFSTYPENAMELEN];   /* fs type name */
	 char	     f_mntonname[MAXPATHLEN];	     /* directory on which mounted */
	 char	     f_mntfromname[MAXPATHLEN];      /* mounted filesystem */
	 uint32_t    f_reserved[8];  /* For future use */
     };

     (In 10.5, 64-bit _i_n_o___t, larger statfs structure and variant symbol were
     available if the macro _DARWIN_USE_64_BIT_INODE is defined before any
     header files are included; this macro is optional in 10.6.)

     If the macro _DARWIN_NO_64_BIT_INODE is defined before any header files
     are included, or if the deployment target is less than 10.6, the legacy
     statfs structure will be in effect.  The _i_n_o___t type will be 32 bits (the
     _DARWIN_FEATURE_64_BIT_INODE macro will not be defined), the strings in
     the statfs structure will be their smaller legacy size (and long mount
     paths may no longer fit) and the undecorated symbol _getfsstat will be
     used.  This legacy _s_t_a_t_f_s structure is defined as:

     #define MFSNAMELEN      15 /* length of fs type name, not inc. nul */
     #define MNAMELEN	     90 /* length of buffer for returned name */

     struct statfs { /* when _DARWIN_FEATURE_64_BIT_INODE is NOT defined */
	 short	 f_otype;    /* type of file system (reserved: zero) */
	 short	 f_oflags;   /* copy of mount flags (reserved: zero) */
	 long	 f_bsize;    /* fundamental file system block size */
	 long	 f_iosize;   /* optimal transfer block size */
	 long	 f_blocks;   /* total data blocks in file system */
	 long	 f_bfree;    /* free blocks in fs */
	 long	 f_bavail;   /* free blocks avail to non-superuser */
	 long	 f_files;    /* total file nodes in file system */
	 long	 f_ffree;    /* free file nodes in fs */
	 fsid_t  f_fsid;     /* file system id */
	 uid_t	 f_owner;    /* user that mounted the file system */
	 short	 f_reserved1;	     /* reserved for future use */
	 short	 f_type;     /* type of file system (reserved) */
	 long	 f_flags;    /* copy of mount flags (reserved) */
	 long	 f_reserved2[2];     /* reserved for future use */
	 char	 f_fstypename[MFSNAMELEN]; /* fs type name */
	 char	 f_mntonname[MNAMELEN];    /* directory on which mounted */
	 char	 f_mntfromname[MNAMELEN];  /* mounted file system */
	 char	 f_reserved3;	     /* reserved for future use */
	 long	 f_reserved4[4];     /* reserved for future use */
     };

     Fields that are undefined for a particular file system are set to -1.
     The buffer is filled with an array of _s_t_a_t_f_s structures, one for each
     mounted file system up to the size specified by _b_u_f_s_i_z_e.

     If _b_u_f is given as NULL, ggeettffssssttaatt() returns just the number of mounted
     file systems.

     If _f_l_a_g_s is set to MNT_NOWAIT, ggeettffssssttaatt() will directly return the
     information retained in the kernel to avoid delays caused by waiting for
     updated information from a file system that is perhaps temporarily unable
     to respond.  Some of the information returned may be out of date, how-
     ever; if _f_l_a_g_s is set to MNT_WAIT or MNT_DWAIT instead, ggeettffssssttaatt() will
     request updated information from each mounted filesystem before return-
     ing.

RREETTUURRNN VVAALLUUEESS
     Upon successful completion, the number of _s_t_a_t_f_s structures is returned.
     Otherwise, -1 is returned and the global variable _e_r_r_n_o is set to indi-
     cate the error.

EERRRROORRSS
     GGeettffssssttaatt() fails if one or more of the following are true:

     [EFAULT]		The _b_u_f argument points to an invalid address.

     [EIO]		An I/O error occurred while reading from or writing to
			the file system.

TTRRAANNSSIITTIIOONNAALL DDEESSCCRRIIPPTTIIOONN ((NNOOWW DDEEPPRREECCAATTEEDD))
     The ggeettffssssttaatt6644() routine is equivalent to the default ggeettffssttaatt() (when
     _DARWIN_FEATURE_64_BIT_INODE is defined), so there is no longer any rea-
     son to use it (it will be removed in the future).

SSEEEE AALLSSOO
     statfs(2), fstab(5), mount(8)

HHIISSTTOORRYY
     The ggeettffssssttaatt() function first appeared in 4.4BSD.

BSD				 Oct 28, 2008				   BSD

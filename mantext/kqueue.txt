KQUEUE(2)		    BSD System Calls Manual		     KQUEUE(2)

NNAAMMEE
     kkqquueeuuee, kkeevveenntt, and kkeevveenntt6644 -- kernel event notification mechanism

LLIIBBRRAARRYY
     Standard C Library (libc, -lc)

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ttyyppeess..hh>>
     ##iinncclluuddee <<ssyyss//eevveenntt..hh>>
     ##iinncclluuddee <<ssyyss//ttiimmee..hh>>

     _i_n_t
     kkqquueeuuee(_v_o_i_d);

     _i_n_t
     kkeevveenntt(_i_n_t _k_q, _c_o_n_s_t _s_t_r_u_c_t _k_e_v_e_n_t _*_c_h_a_n_g_e_l_i_s_t, _i_n_t _n_c_h_a_n_g_e_s,
	 _s_t_r_u_c_t _k_e_v_e_n_t _*_e_v_e_n_t_l_i_s_t, _i_n_t _n_e_v_e_n_t_s,
	 _c_o_n_s_t _s_t_r_u_c_t _t_i_m_e_s_p_e_c _*_t_i_m_e_o_u_t);

     _i_n_t
     kkeevveenntt6644(_i_n_t _k_q, _c_o_n_s_t _s_t_r_u_c_t _k_e_v_e_n_t_6_4___s _*_c_h_a_n_g_e_l_i_s_t, _i_n_t _n_c_h_a_n_g_e_s,
	 _s_t_r_u_c_t _k_e_v_e_n_t_6_4___s _*_e_v_e_n_t_l_i_s_t, _i_n_t _n_e_v_e_n_t_s, _u_n_s_i_g_n_e_d _i_n_t _f_l_a_g_s,
	 _c_o_n_s_t _s_t_r_u_c_t _t_i_m_e_s_p_e_c _*_t_i_m_e_o_u_t);

     EEVV__SSEETT(_&_k_e_v, _i_d_e_n_t, _f_i_l_t_e_r, _f_l_a_g_s, _f_f_l_a_g_s, _d_a_t_a, _u_d_a_t_a);

     EEVV__SSEETT6644(_&_k_e_v, _i_d_e_n_t, _f_i_l_t_e_r, _f_l_a_g_s, _f_f_l_a_g_s, _d_a_t_a, _u_d_a_t_a, _e_x_t_[_0_],
	 _e_x_t_[_1_]);

DDEESSCCRRIIPPTTIIOONN
     The kkqquueeuuee() system call provides a generic method of notifying the user
     when an kernel event (kevent) happens or a condition holds, based on the
     results of small pieces of kernel code termed filters.  A kevent is iden-
     tified by an (ident, filter) pair and specifies the interesting condi-
     tions to be notified about for that pair.	An (ident, filter) pair can
     only appear once in a given kqueue.  Subsequent attempts to register the
     same pair for a given kqueue will result in the replacement of the condi-
     tions being watched, not an addition.

     The filter identified in a kevent is executed upon the initial registra-
     tion of that event in order to detect whether a preexisting condition is
     present, and is also executed whenever an event is passed to the filter
     for evaluation.  If the filter determines that the condition should be
     reported, then the kevent is placed on the kqueue for the user to
     retrieve.

     The filter is also run when the user attempts to retrieve the kevent from
     the kqueue.  If the filter indicates that the condition that triggered
     the event no longer holds, the kevent is removed from the kqueue and is
     not returned.

     Multiple events which trigger the filter do not result in multiple
     kevents being placed on the kqueue; instead, the filter will aggregate
     the events into a single struct kevent.  Calling cclloossee() on a file
     descriptor will remove any kevents that reference the descriptor.

     The kkqquueeuuee() system call creates a new kernel event queue and returns a
     descriptor.  The queue is not inherited by a child created with fork(2).

     The kkeevveenntt() and kkeevveenntt6644() system calls are used to register events with
     the queue, and return any pending events to the user.  The _c_h_a_n_g_e_l_i_s_t
     argument is a pointer to an array of _k_e_v_e_n_t or _k_e_v_e_n_t_6_4___s structures, as
     defined in <_s_y_s_/_e_v_e_n_t_._h>.	All changes contained in the _c_h_a_n_g_e_l_i_s_t are
     applied before any pending events are read from the queue.  The _n_c_h_a_n_g_e_s
     argument gives the size of _c_h_a_n_g_e_l_i_s_t.  The _e_v_e_n_t_l_i_s_t argument is a
     pointer to an array of _k_e_v_e_n_t or _k_e_v_e_n_t_6_4___s structures.  The _n_e_v_e_n_t_s
     argument determines the size of _e_v_e_n_t_l_i_s_t.  If _t_i_m_e_o_u_t is a non-NULL
     pointer, it specifies a maximum interval to wait for an event, which will
     be interpreted as a struct timespec.  If _t_i_m_e_o_u_t is a NULL pointer, both
     kkeevveenntt() and kkeevveenntt6644() wait indefinitely.  To effect a poll, the _t_i_m_e_o_u_t
     argument should be non-NULL, pointing to a zero-valued _t_i_m_e_s_p_e_c struc-
     ture.  The same array may be used for the _c_h_a_n_g_e_l_i_s_t and _e_v_e_n_t_l_i_s_t.

     The EEVV__SSEETT() macro is provided for ease of initializing a _k_e_v_e_n_t struc-
     ture. Similarly, EEVV__SSEETT6644() initializes a _k_e_v_e_n_t_6_4___s structure.

     The _k_e_v_e_n_t and _k_e_v_e_n_t_6_4___s structures are defined as:

     struct kevent {
	     uintptr_t	     ident;	     /* identifier for this event */
	     int16_t	     filter;	     /* filter for event */
	     uint16_t	     flags;	     /* general flags */
	     uint32_t	     fflags;	     /* filter-specific flags */
	     intptr_t	     data;	     /* filter-specific data */
	     void	     *udata;	     /* opaque user data identifier */
     };


     struct kevent64_s {
	     uint64_t	     ident;	     /* identifier for this event */
	     int16_t	     filter;	     /* filter for event */
	     uint16_t	     flags;	     /* general flags */
	     uint32_t	     fflags;	     /* filter-specific flags */
	     int64_t	     data;	     /* filter-specific data */
	     uint64_t	     udata;	     /* opaque user data identifier */
	     uint64_t	     ext[2];	     /* filter-specific extensions */
     };

     ----

     The fields of _s_t_r_u_c_t _k_e_v_e_n_t and _s_t_r_u_c_t _k_e_v_e_n_t_6_4___s are:

     ident	Value used to identify this event.  The exact interpretation
		is determined by the attached filter, but often is a file
		descriptor.

     filter	Identifies the kernel filter used to process this event.  The
		pre-defined system filters are described below.

     flags	Actions to perform on the event.

     fflags	Filter-specific flags.

     data	Filter-specific data value.

     udata	Opaque user-defined value passed through the kernel unchanged.

     In addition, _s_t_r_u_c_t _k_e_v_e_n_t_6_4___s contains:

     ext[2]	This field stores extensions for the event's filter. What type
		of extension depends on what type of filter is being used.

     ----

     The _f_l_a_g_s field can contain the following values:

     EV_ADD	    Adds the event to the kqueue.  Re-adding an existing event
		    will modify the parameters of the original event, and not
		    result in a duplicate entry.  Adding an event automati-
		    cally enables it, unless overridden by the EV_DISABLE
		    flag.

     EV_ENABLE	    Permit kkeevveenntt() and kkeevveenntt6644() to return the event if it
		    is triggered.

     EV_DISABLE     Disable the event so kkeevveenntt() and kkeevveenntt6644() will not
		    return it.	The filter itself is not disabled.

     EV_DELETE	    Removes the event from the kqueue.	Events which are
		    attached to file descriptors are automatically deleted on
		    the last close of the descriptor.

     EV_RECEIPT     This flag is useful for making bulk changes to a kqueue
		    without draining any pending events. When passed as input,
		    it forces EV_ERROR to always be returned.  When a filter
		    is successfully added. The _d_a_t_a field will be zero.

     EV_ONESHOT     Causes the event to return only the first occurrence of
		    the filter being triggered.  After the user retrieves the
		    event from the kqueue, it is deleted.

     EV_CLEAR	    After the event is retrieved by the user, its state is
		    reset.  This is useful for filters which report state
		    transitions instead of the current state.  Note that some
		    filters may automatically set this flag internally.

     EV_EOF	    Filters may set this flag to indicate filter-specific EOF
		    condition.

     EV_ERROR	    See _R_E_T_U_R_N _V_A_L_U_E_S below.

     ----

     The predefined system filters are listed below.  Arguments may be passed
     to and from the filter via the _f_f_l_a_g_s and _d_a_t_a fields in the _k_e_v_e_n_t or
     _k_e_v_e_n_t_6_4___s structure.

     EVFILT_READ      Takes a file descriptor as the identifier, and returns
		      whenever there is data available to read.  The behavior
		      of the filter is slightly different depending on the
		      descriptor type.

		      Sockets
			  Sockets which have previously been passed to
			  lliisstteenn() return when there is an incoming connection
			  pending.  _d_a_t_a contains the size of the listen back-
			  log.

			  Other socket descriptors return when there is data
			  to be read, subject to the SO_RCVLOWAT value of the
			  socket buffer.  This may be overridden with a per-
			  filter low water mark at the time the filter is
			  added by setting the NOTE_LOWAT flag in _f_f_l_a_g_s, and
			  specifying the new low water mark in _d_a_t_a.  On
			  return, _d_a_t_a contains the number of bytes of proto-
			  col data available to read.

			  If the read direction of the socket has shutdown,
			  then the filter also sets EV_EOF in _f_l_a_g_s, and
			  returns the socket error (if any) in _f_f_l_a_g_s.	It is
			  possible for EOF to be returned (indicating the con-
			  nection is gone) while there is still data pending
			  in the socket buffer.

		      Vnodes
			  Returns when the file pointer is not at the end of
			  file.  _d_a_t_a contains the offset from current posi-
			  tion to end of file, and may be negative.

		      Fifos, Pipes
			  Returns when the there is data to read; _d_a_t_a con-
			  tains the number of bytes available.

			  When the last writer disconnects, the filter will
			  set EV_EOF in _f_l_a_g_s.	This may be cleared by passing
			  in EV_CLEAR, at which point the filter will resume
			  waiting for data to become available before return-
			  ing.

     EVFILT_WRITE     Takes a file descriptor as the identifier, and returns
		      whenever it is possible to write to the descriptor.  For
		      sockets, pipes and fifos, _d_a_t_a will contain the amount
		      of space remaining in the write buffer.  The filter will
		      set EV_EOF when the reader disconnects, and for the fifo
		      case, this may be cleared by use of EV_CLEAR.  Note that
		      this filter is not supported for vnodes.

		      For sockets, the low water mark and socket error han-
		      dling is identical to the EVFILT_READ case.

     EVFILT_AIO       This filter is currently unsupported.

     EVFILT_VNODE     Takes a file descriptor as the identifier and the events
		      to watch for in _f_f_l_a_g_s, and returns when one or more of
		      the requested events occurs on the descriptor.  The
		      events to monitor are:

		      NOTE_DELETE    The uunnlliinnkk() system call was called on
				     the file referenced by the descriptor.

		      NOTE_WRITE     A write occurred on the file referenced
				     by the descriptor.

		      NOTE_EXTEND    The file referenced by the descriptor was
				     extended.

		      NOTE_ATTRIB    The file referenced by the descriptor had
				     its attributes changed.

		      NOTE_LINK      The link count on the file changed.

		      NOTE_RENAME    The file referenced by the descriptor was
				     renamed.

		      NOTE_REVOKE    Access to the file was revoked via
				     revoke(2) or the underlying fileystem was
				     unmounted.

		      On return, _f_f_l_a_g_s contains the events which triggered
		      the filter.

     EVFILT_PROC      Takes the process ID to monitor as the identifier and
		      the events to watch for in _f_f_l_a_g_s, and returns when the
		      process performs one or more of the requested events.
		      If a process can normally see another process, it can
		      attach an event to it.  The events to monitor are:

		      NOTE_EXIT    The process has exited.

		      NOTE_FORK    The process created a child process via
				   fork(2) or similar call.

		      NOTE_EXEC    The process executed a new process via
				   execve(2) or similar call.

		      NOTE_SIGNAL  The process was sent a signal. Status can
				   be checked via waitpid(2) or similar call.

		      NOTE_REAP    The process was reaped by the parent via
				   wait(2) or similar call.

		      On return, _f_f_l_a_g_s contains the events which triggered
		      the filter.

     EVFILT_SIGNAL    Takes the signal number to monitor as the identifier and
		      returns when the given signal is generated for the
		      process.	This coexists with the ssiiggnnaall() and
		      ssiiggaaccttiioonn() facilities, and has a lower precedence.
		      Only signals sent to the process, not to a particular
		      thread, will trigger the filter. The filter will record
		      all attempts to deliver a signal to a process, even if
		      the signal has been marked as SIG_IGN.  Event notifica-
		      tion happens before normal signal delivery processing.
		      _d_a_t_a returns the number of times the signal has been
		      generated since the last call to kkeevveenntt().  This filter
		      automatically sets the EV_CLEAR flag internally.

     EVFILT_MACHPORT  Takes the name of a mach port, or port set, in _i_d_e_n_t and
		      waits until a message is received on the port or port
		      set. When a message is recieved, the size of the message
		      is returned in _d_a_t_a and if _f_f_l_a_g_s is set to
		      MACH_RCV_MSG, a pointer to the message is returned in
		      ext[0].

     EVFILT_TIMER     Establishes an interval timer with the data timer iden-
		      tified by _i_d_e_n_t.	When adding a timer, _d_a_t_a specifies
		      the timeout period and _f_f_l_a_g_s can be set to one of the
		      following:

		      NOTE_SECONDS   data is in seconds

		      NOTE_USECONDS  data is in microseconds

		      NOTE_NSECONDS  data is in nanoseconds

		      NOTE_ABSOLUTE  data is an absolute timeout

		      If fflags is not set, the default is milliseconds. The
		      timer will be periodic unless EV_ONESHOT is specified.
		      On return, _d_a_t_a contains the number of times the timeout
		      has expired since the last call to kkeevveenntt() or
		      kkeevveenntt6644().  This filter automatically sets the EV_CLEAR
		      flag internally.

     EVFILT_SESSION   Takes the audit session ID to monitor as the identifier
		      and the events to watch for in _f_f_l_a_g_s, and returns when
		      one or more of the requested session events occurs.  To
		      monitor for events for any audit session the value
		      AS_ANY_ASID should be used as the identifier.  With
		      AS_ANY_ASID, as new audit sessions are created they are
		      included as if the were added individually.  The events
		      to monitor are:

		      NOTE_AS_START   A new audit session has started.

		      NOTE_AS_END     All the processes in the audit session
				      have exited.

		      NOTE_AS_CLOSE   This audit session is no longer valid in
				      the kernel.  In other words, it is now
				      safe to dispose of any cached informa-
				      tion about this session or reuse its
				      session ID for a new audit session.

		      NOTE_AS_UPDATE  The audit session information was
				      updated.	The audit session information
				      is considered immutable once initially
				      set.  If this becomes enforced in the
				      kernel then this event may no longer be
				      needed and may become obsolete.

		      NOTE_AS_ERR     This flag is returned if the system was
				      unable to attach an event to a new ses-
				      sion when the audit session ID of
				      AS_ANY_ASID is used.  This is usually
				      due to resource limitations.

		      On return, _f_f_l_a_g_s contains the events which triggered
		      the filter, _i_d_e_n_t contains the audit session ID, and
		      _d_a_t_a contains the audit user ID.	This filter automati-
		      cally sets the EV_CLEAR flag internally.

     ----

     In the _e_x_t_[_2_] field of the _k_e_v_e_n_t_6_4___s struture, _e_x_t_[_0_] is only used with
     the EVFILT_MACHPORT filter.  With other filters, _e_x_t_[_0_] is passed through
     kkeevveenntt6644() much like _u_d_a_t_a.  _e_x_t_[_1_] can always be used like _u_d_a_t_a.  For
     the use of ext[0], see the EVFILT_MACHPORT filter above.

RREETTUURRNN VVAALLUUEESS
     The kkqquueeuuee() system call creates a new kernel event queue and returns a
     file descriptor.  If there was an error creating the kernel event queue,
     a value of -1 is returned and errno set.

     The kkeevveenntt() and kkeevveenntt6644() system calls return the number of events
     placed in the _e_v_e_n_t_l_i_s_t, up to the value given by _n_e_v_e_n_t_s.  If an error
     occurs while processing an element of the _c_h_a_n_g_e_l_i_s_t and there is enough
     room in the _e_v_e_n_t_l_i_s_t, then the event will be placed in the _e_v_e_n_t_l_i_s_t
     with EV_ERROR set in _f_l_a_g_s and the system error in _d_a_t_a.  Otherwise, -1
     will be returned, and errno will be set to indicate the error condition.
     If the time limit expires, then kkeevveenntt() and kkeevveenntt6644() return 0.

EERRRROORRSS
     The kkqquueeuuee() system call fails if:

     [ENOMEM]		The kernel failed to allocate enough memory for the
			kernel queue.

     [EMFILE]		The per-process descriptor table is full.

     [ENFILE]		The system file table is full.

     The kkeevveenntt() and kkeevveenntt6644() system calls fail if:

     [EACCES]		The process does not have permission to register a
			filter.

     [EFAULT]		There was an error reading or writing the _k_e_v_e_n_t or
			_k_e_v_e_n_t_6_4___s structure.

     [EBADF]		The specified descriptor is invalid.

     [EINTR]		A signal was delivered before the timeout expired and
			before any events were placed on the kqueue for
			return.

     [EINVAL]		The specified time limit or filter is invalid.

     [ENOENT]		The event could not be found to be modified or
			deleted.

     [ENOMEM]		No memory was available to register the event.

     [ESRCH]		The specified process to attach to does not exist.

SSEEEE AALLSSOO
     aio_error(2), aio_read(2), aio_return(2), read(2), select(2),
     sigaction(2), write(2), signal(3)

HHIISSTTOORRYY
     The kkqquueeuuee() and kkeevveenntt() system calls first appeared in FreeBSD 4.1.

AAUUTTHHOORRSS
     The kkqquueeuuee() system and this manual page were written by Jonathan Lemon
     <jlemon@FreeBSD.org>.

BBUUGGSS
     Not all filesystem types support kqueue-style notifications.  And even
     some that do, like some remote filesystems, may only support a subset of
     the notification semantics described here.

BSD			       October 21, 2008 			   BSD

MKDIR(2)		    BSD System Calls Manual		      MKDIR(2)

NNAAMMEE
     mmkkddiirr -- make a directory file

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ssttaatt..hh>>

     _i_n_t
     mmkkddiirr(_c_o_n_s_t _c_h_a_r _*_p_a_t_h, _m_o_d_e___t _m_o_d_e);

DDEESSCCRRIIPPTTIIOONN
     The directory _p_a_t_h is created with the access permissions specified by
     _m_o_d_e and restricted by the umask(2) of the calling process. See chmod(2)
     for the possible permission bit masks for _m_o_d_e.

     The directory's owner ID is set to the process's effective user ID.  The
     directory's group ID is set to that of the parent directory in which it
     is created.

     Note: the behavior of mmkkddiirr() is undefined when mode bits other than the
     low 9 bits are used. Use chmod(2) after mmkkddiirr() to explicitly set the
     other bits (See example below).

RREETTUURRNN VVAALLUUEESS
     A 0 return value indicates success.  A -1 return value indicates an
     error, and an error code is stored in _e_r_r_n_o.

EERRRROORRSS
     MMkkddiirr() will fail and no directory will be created if:

     [EACCES]		Search permission is denied for a component of the
			path prefix.

     [EACCES]		Write permission is denied for the parent directory.

     [EDQUOT]		The new directory cannot be created because the user's
			quota of disk blocks on the file system that will con-
			tain the directory has been exhausted.

     [EDQUOT]		The user's quota of inodes on the file system on which
			the directory is being created has been exhausted.

     [EEXIST]		The named file exists.

     [EFAULT]		_P_a_t_h points outside the process's allocated address
			space.

     [EIO]		An I/O error occurred while making the directory entry
			or allocating the inode.

     [EIO]		An I/O error occurred while reading from or writing to
			the file system.

     [ELOOP]		Too many symbolic links were encountered in translat-
			ing the pathname.  This is taken to be indicative of a
			looping symbolic link.

     [EMLINK]		The parent directory already has {LINK_MAX} links.

     [ENAMETOOLONG]	A component of a pathname exceeded {NAME_MAX} charac-
			ters, or an entire path name exceeded {PATH_MAX} char-
			acters.

     [ENOENT]		A component of the path prefix does not exist or path
			is an empty string.

     [ENOSPC]		The new directory cannot be created because there is
			no space left on the file system that would contain
			it.

     [ENOSPC]		There are no free inodes on the file system on which
			the directory is being created.

     [ENOTDIR]		A component of the path prefix is not a directory.

     [EROFS]		The parent directory resides on a read-only file sys-
			tem.

EEXXAAMMPPLLEE
	   int main (int argc, const char * argv[])
	   {
		   /* The behavior of mkdir is undefined for anything other than the "permission" bits */
		   if (mkdir("/tmp/blah", 0777))
			   perror("/tmp/blah");

		   /* So we need to set the sticky/executable bits explicitly with chmod after calling mkdir */
		   if (chmod("/tmp/blah", 07777))
			   perror("/tmp/blah");
	   }


LLEEGGAACCYY SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ttyyppeess..hh>>
     ##iinncclluuddee <<ssyyss//ssttaatt..hh>>

     The include file <_s_y_s_/_t_y_p_e_s_._h> is necessary.

SSEEEE AALLSSOO
     chmod(2), stat(2), umask(2), compat(5)

SSTTAANNDDAARRDDSS
     The mmkkddiirr() function conforms to IEEE Std 1003.1-1988 (``POSIX.1'').

4.2 Berkeley Distribution      December 11, 1993     4.2 Berkeley Distribution

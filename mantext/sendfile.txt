SENDFILE(2)		    BSD System Calls Manual		   SENDFILE(2)

NNAAMMEE
     sseennddffiillee -- send a file to a socket

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ttyyppeess..hh>>
     ##iinncclluuddee <<ssyyss//ssoocckkeett..hh>>
     ##iinncclluuddee <<ssyyss//uuiioo..hh>>

     _i_n_t
     sseennddffiillee(_i_n_t _f_d, _i_n_t _s, _o_f_f___t _o_f_f_s_e_t, _o_f_f___t _*_l_e_n, _s_t_r_u_c_t _s_f___h_d_t_r _*_h_d_t_r,
	 _i_n_t _f_l_a_g_s);

DDEESSCCRRIIPPTTIIOONN
     The sseennddffiillee() system call sends a regular file specified by descriptor
     _f_d out a stream socket specified by descriptor _s.

     The _o_f_f_s_e_t argument specifies where to begin in the file.	Should _o_f_f_s_e_t
     fall beyond the end of file, the system will return success and report 0
     bytes sent as described below.

     The _l_e_n argument is a value-result parameter, that specifies how many
     bytes of the file should be sent and/or how many bytes have been sent.
     Initially the value pointed to by the _l_e_n argument specifies how many
     bytes should be sent with 0 having the special meaning to send until the
     end of file has been reached.  On return the value pointed to by the _l_e_n
     argument indicates how many bytes have been sent, except when a header or
     trailer is specified as shown below.  The _l_e_n pointer may not be NULL.

     An optional header and/or trailer can be sent before and after the file
     data by specifying a pointer to a _s_t_r_u_c_t _s_f___h_d_t_r, which has the following
     structure:

	   struct sf_hdtr {
		   struct iovec *headers;  /* pointer to header iovecs */
		   int hdr_cnt; 	   /* number of header iovecs */
		   struct iovec *trailers; /* pointer to trailer iovecs */
		   int trl_cnt; 	   /* number of trailer iovecs */
	   };

     The _h_e_a_d_e_r_s and _t_r_a_i_l_e_r_s pointers, if non-NULL, point to arrays of _s_t_r_u_c_t
     _i_o_v_e_c structures.	See the wwrriitteevv() system call for information on the
     iovec structure.  The number of iovecs in these arrays is specified by
     _h_d_r___c_n_t and _t_r_l___c_n_t.

     When a header or trailer is specified the value of _l_e_n returned will
     include the size of header or trailer sent. The user should provide suf-
     ficiently large value of _l_e_n as argument including the size of header or
     trailer, otherwise only part of file data will be sent following the
     header.

     The _f_l_a_g_s parameter is reserved for future expansion and must be set to
     0. Any other value will cause sseennddffiillee() to return EINVAL.

     When using a socket marked for non-blocking I/O, sseennddffiillee() may send
     fewer bytes than requested.  In this case, the number of bytes success-
     fully sent is returned in the via the _l_e_n parameters and the error EAGAIN
     is returned.

     When a signal causes sseennddffiillee() to return the error EINTR, the _l_e_n argu-
     ment may return 0 without necessarily meaning the end of file has been
     reached as the signal may have been caught before any data was sent.

IIMMPPLLEEMMEENNTTAATTIIOONN NNOOTTEESS
     The Mac OS X implementation of sseennddffiillee() uses 64 bits types for size and
     offset parameters so there is no need for a 64 bits version sseennddffiillee6644()
     as found on some other operating systems.

RREETTUURRNN VVAALLUUEESS
     The sseennddffiillee() function returns the value 0 if successful; otherwise the
     value -1 is returned and the global variable _e_r_r_n_o is set to indicate the
     error.

     The number of bytes sent is returned via the parameter _l_e_n.  A value of 0
     means the end of the file specified by descriptor _f_d has been reached or
     that the value passed in _o_f_f_s_e_t falls beyond the end of file.

EERRRROORRSS
     [EAGAIN]		The socket is marked for non-blocking I/O and not all
			data was sent due to the socket buffer being full.  If
			specified, the number of bytes successfully sent will
			be returned in _*_l_e_n.

     [EBADF]		The _f_d argument is not a valid file descriptor.

     [ENOTSUP]		The _f_d argument does not refer to a regular file.

     [EBADF]		The _s argument is not a valid socket descriptor.

     [ENOTSOCK] 	The _s argument does not refer stream oriented socket.

     [EFAULT]		An invalid address was specified for an argument.

     [EINTR]		A signal interrupted sseennddffiillee() before it could be
			completed.  If specified, the number of bytes success-
			fully sent will be returned in _*_l_e_n.

     [EINVAL]		The _o_f_f_s_e_t argument is negative.

     [EINVAL]		The _l_e_n argument is NULL.

     [EINVAL]		The _f_l_a_g_s argument is not set to 0.

     [EIO]		An error occurred while reading from _f_d.

     [ENOTCONN] 	The _s argument points to an unconnected socket.

     [ENOTSOCK] 	The _s argument is not a socket.

     [EOPNOTSUPP]	The file system for descriptor _f_d does not support
			sseennddffiillee().

     [EPIPE]		The socket peer has closed the connection.

SSEEEE AALLSSOO
     open(2), send(2), socket(2), writev(2)

HHIISSTTOORRYY
     The sseennddffiillee() system call first appeared in Darwin 9.0 (Mac OS X version
     10.5) .

AAUUTTHHOORRSS
     This manual page is based on the FreeBSD version written by David G.
     Lawrence <dg@dglawrence.com>

Mac OS X			March 31, 2006			      Mac OS X
